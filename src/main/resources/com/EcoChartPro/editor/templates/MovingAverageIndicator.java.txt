package com.EcoChartPro.plugins.inapp;

import com.EcoChartPro.api.indicator.*;
import com.EcoChartPro.api.indicator.drawing.DataPoint;
import com.EcoChartPro.api.indicator.drawing.DrawableObject;
import com.EcoChartPro.api.indicator.drawing.DrawablePolyline;
import com.EcoChartPro.core.indicator.IndicatorContext;
import java.awt.Color;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

public class MovingAverageIndicator implements CustomIndicator {
    @Override public String getName() { return "Moving Average"; }
    @Override public IndicatorType getType() { return IndicatorType.OVERLAY; }

    @Override
    public List<Parameter> getParameters() {
        return List.of(
            new Parameter("period", ParameterType.INTEGER, 20),
            new Parameter("color", ParameterType.COLOR, Color.ORANGE)
        );
    }

    @Override
    public List<DrawableObject> calculate(IndicatorContext context) {
        // Correctly use the ApiKLine type provided by the context.
        List<ApiKLine> data = context.klineData();
        int period = (int) context.settings().get("period");
        Color color = (Color) context.settings().get("color");

        if (data.size() < period) return Collections.emptyList();

        // Use the public API utility to extract close prices and calculate the SMA.
        List<BigDecimal> closePrices = IndicatorUtils.extractSourceData(data, ApiKLine::close);
        List<BigDecimal> smaValues = IndicatorUtils.calculateSMA(closePrices, period);

        // --- Create DataPoints for the polyline ---
        List<DataPoint> maPoints = new ArrayList<>();
        // The SMA result is shorter, so we must align it with the correct timestamps.
        // The first SMA value corresponds to the k-line at index (period - 1).
        for (int i = 0; i < smaValues.size(); i++) {
            int klineIndex = i + period - 1;
            maPoints.add(new DataPoint(data.get(klineIndex).timestamp(), smaValues.get(i)));
        }

        return List.of(new DrawablePolyline(maPoints, color, 1.5f));
    }
}